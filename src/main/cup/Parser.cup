import java_cup.runtime.*;
import java.util.*;
import java.io.*;

action code {:
  /** 
  * funciones p√∫blicas de pruebas para el lexer, por ahora
  * solo imprimen en consola
  * entrada: ninguna
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola
  */
  HashMap<String, SymbolTable> tablasSimbolos = new HashMap<String, SymbolTable>();

  String currentHash = "";
  ArrayList<FirmaFuncion> firmasFunciones = new ArrayList<FirmaFuncion>();
  ArrayList<String> registrosSinUsar = new ArrayList<String>(Arrays.asList("$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9"));
  ArrayList<String> registrosFloatSinUsar = new ArrayList<String>(Arrays.asList("$f0", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7", "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15", "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23", "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"));

  public void refrescarRegistros() {
    registrosSinUsar = new ArrayList<String>(Arrays.asList("$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9"));
  }

  public void refrescarRegistrosFloat() {
    registrosFloatSinUsar = new ArrayList<String>(Arrays.asList("$f0", "$f2", "$f3", "$f4", "$f5", "$f6", "$f7", "$f8", "$f9", "$f10", "$f11", "$f12", "$f13", "$f14", "$f15", "$f16", "$f17", "$f18", "$f19", "$f20", "$f21", "$f22", "$f23", "$f24", "$f25", "$f26", "$f27", "$f28", "$f29", "$f30", "$f31"));
  }

  public void addFirmaFuncion(FirmaFuncion firma) {
    firmasFunciones.add(firma);
  }

  public String getUnoccupiedRegister() {
    
    if (registrosSinUsar.size() == 0) {

      System.out.println("Refrescando debido a falta de registros");
      // workaround temporal: refrescar registros
      refrescarRegistros();
      return getUnoccupiedRegister();
    }
    var reg = registrosSinUsar.get(0);
    registrosSinUsar.remove(0);
    return reg;
  }

  public String getUnoccupiedFloatRegister() {
    
    if (registrosFloatSinUsar.size() == 0) {

      System.out.println("Refrescando debido a falta de registros");
      // workaround temporal: refrescar registros
      refrescarRegistrosFloat();
      return getUnoccupiedFloatRegister();
    }
    var reg = registrosFloatSinUsar.get(0);
    registrosFloatSinUsar.remove(0);
    return reg;
  }

  public FirmaFuncion encontrarFuncion(String id) {
    for (FirmaFuncion firma : firmasFunciones) {
      if (firma.getNombre().equals(id)) {
        return firma;
      }
    }
    return null;
  }

  public FirmaFuncion functionActual() {
    return firmasFunciones.get(firmasFunciones.size() - 1);
  }


  /**
  * funci√≥n para imprimir la tabla de s√≠mbolos
  * entrada: ninguna
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola la tabla de s√≠mbolos
  */
  public void imprimirTablaSimbolos() {
    for (String key : tablasSimbolos.keySet()) {
      System.out.println("Tabla: " + key);
      var val = tablasSimbolos.get(key);
      val.imprimirTablaSimbolos();
    }
  }

  public void exportarTablaSimbolos() {
    List<String[]> data = new ArrayList<String[]>();
    data.add(new String[] {"Tabla", "TipoEntrada", "Nombre", "TipoDato"});
    for (String key : tablasSimbolos.keySet()) {
      var value = tablasSimbolos.get(key);
      for (SymbolTableObject value2 : value.getSymbolTable()) {
        data.add(new String[] {key, value2.getTipoEntrada(), value2.getNombre(), value2.getTipoDato()});
      }
    }
    
    MarkdownTablePrinter tablePrinter = new MarkdownTablePrinter(data, "src/main/test/tabla_sim.md");
    tablePrinter.print();
    System.out.println("Tabla de simbolos exportada a tabla_sim.md");
  }

  /**
  * Funci√≥n para conseguir el tipo de un s√≠mbolo en la tabla de s√≠mbolos actual
  * entrada: un string
  * salida: un Expresion.TipoExpresion
  * restricciones: ninguna
  * objetivo: conseguir el tipo de un s√≠mbolo en la tabla de s√≠mbolos actual
  */
  public TipoExpresion getTipo(String nombre, boolean picarError) {
    for (SymbolTableObject value : tablasSimbolos.get(currentHash).getSymbolTable()) {
      if (value.getNombre().equals(nombre)) {
        return Expresion.tipoFromString(value.getTipoDato());
      }
    }
    if (picarError){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + nombre + " no declarada en el alcance actual");
    }
    return TipoExpresion.NULL;
  }

  public void addDireccion(String id, String dir){
    for (SymbolTableObject value : tablasSimbolos.get(currentHash).getSymbolTable()) {
      if (value.getNombre().equals(id)) {
        value.setDireccion(dir);
      }
    }
  }

  public String getDireccion(String id){
    for (SymbolTableObject value : tablasSimbolos.get(currentHash).getSymbolTable()) {
      if (value.getNombre().equals(id)) {
        return value.getDireccion();
      }
    }
    return null;
  }


  /**
  * funci√≥n para cambiar el hash actual al que se le asocian los s√≠mbolos
  * entrada: un string
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: cambiar el hash actual
  */
  public void setHash(String hash) {
    currentHash = hash;
    tablasSimbolos.put(hash, new SymbolTable());
  }
  /**
  * funci√≥n para agregar un s√≠mbolo a la tabla de s√≠mbolos
  * entrada: un objeto de la clase SymbolTableObject
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: agregar un s√≠mbolo a la tabla de s√≠mbolos
  */
  public void addSymbol(SymbolTableObject symbol) {
    tablasSimbolos.get(currentHash).getSymbolTable().add(symbol);
  }
:}

parser code {:
  Lexer lex;
  int literalId = 0;
  int labelId = 0;
  String outputPath;
  private final String LIB_PATH = "src/main/asm/santalib.asm";

  StringBuffer dataBuffer = new StringBuffer();
  StringBuffer codeBuffer = new StringBuffer();
  StringBuffer libBuffer = new StringBuffer();

  /* cargar libreria */

  public void cargarLibreria() {
    try {
      File libFile = new File(LIB_PATH);
      java.util.Scanner libScanner = new java.util.Scanner(libFile);
      while (libScanner.hasNextLine()) {
        String line = libScanner.nextLine();
        libBuffer.append(line + "\n");
      }
      libScanner.close();
    } catch (FileNotFoundException e) {
      System.out.println("Error al cargar la libreria");
      e.printStackTrace();
    }
  }

  public TipoExpresion validarTipado(String op, Expresion a, Expresion b, ArrayList<TipoExpresion> tiposValidos) {
    // validar que los tipos de a y b sean iguales
    if (a.getTipo() != b.getTipo()) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipos de datos " + a.getTipo().toString() + " y " + b.getTipo().toString() + " no compatibles para operacion " + op);
      return TipoExpresion.NULL;
    }
    // validar que el tipo de a est√© en la lista de tipos validos
    if (!tiposValidos.contains(a.getTipo())) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + a.getTipo().toString() + " no valido para operacion " + op);
      return TipoExpresion.NULL;
    }

    return a.getTipo();
  }

  // overloading del metodo pero unario
  public TipoExpresion validarTipado(String op, Expresion a, ArrayList<TipoExpresion> tiposValidos) {
    // validar que el tipo de a est√© en la lista de tipos validos
    if (!tiposValidos.contains(a.getTipo())) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + a.getTipo().toString() + " no valido para operacion " + op);
      return TipoExpresion.NULL;
    }

    return a.getTipo();
  }


  public void inicializarBuffers(){
    // carga los buffer codeBuffer y dataBuffer con .text y .data
    codeBuffer.append(".text\n");
    dataBuffer.append(".data\n");
    // a√±adir un endl al dataBuffer 
    dataBuffer.append("endl: .asciiz \"\\n\"\n");
    dataBuffer.append("fzero: .float 0.0\n");
    dataBuffer.append("fone: .float 1.0\n");
    dataBuffer.append("ftwo: .float 2.0\n");
    dataBuffer.append("log2: .float 0.69314718055994\n");
  }


  /**
  * Constructor de la clase parser
  * entrada: un lexer
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: inicializar el lexer y el symbolFactory
  */
  public parser(Lexer lex, String outputPath) {
    this.lex = lex;
    this.outputPath = outputPath;
    cargarLibreria();
    inicializarBuffers();
    this.symbolFactory = new DefaultSymbolFactory();
  }
  /**
  * Sobreescritura de m√©todos para el manejo de errores
  * entrada: un entero y un s√≠mbolo
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola el error
  */
  public void syntax_error(Symbol token) {
    if (token.value == null){
      return;
    }
    System.out.println("Error de sintaxis en la linea " + token.left + " columna " + token.right + ": " + token.value);
    System.out.println("Continuando...");
  }
  public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
    if (token.value == null){
      throw new Exception("Error de sintaxis irrecuperable al final del archivo");
    }
    throw new Exception("Error de sintaxis irrecuperable en la linea " + token.left + " columna " + token.right + ": " + token.value);
  }



:}

// como se escanean e inicializan los tokens
scan with {: return lex.next_token(); :};
init with {: :};

// Definici√≥n de terminales (tokens) a usar
// operaciones aritm√©ticas binarias, renos de Santa ü¶åü¶åü¶åü¶åü¶åü¶åü¶å
terminal op_res_rodolfo, op_sum_cupido, op_div_bailarin;
terminal op_mul_cometa, op_mod_rayo, op_pow_travieso;

// operaciones aritm√©ticas unarias, grinch-quien üéÑüòàüéÖüíö
terminal op_inc_quien, op_dec_grinch;

// operadores relacionales, elfos üßù
terminal op_eq_astuto, op_l_nevado, op_g_alegre, op_geq_feliz;
terminal op_leq_copito, op_neq_chispa; 

// expresiones logicas, reyes magos üëëüëëüëë
terminal op_and_melchor, op_or_gaspar, op_not_baltasar;

// identificador, persona üßë
terminal id_persona;

// tipos de datos, nombres de pap√° noel üéÖüéÖüéÖüéÖüéÖüéÖ
terminal t_int_colacho, t_float_santa, t_bool_noel, t_char_pascuero;
terminal t_string_kris, t_null_reno;

// literales, nombres de pap√° noel üéÖüéÖüéÖüéÖüéÖüéÖ
terminal l_int_colacho, l_float_santa, l_t_noel, l_f_noel;
terminal l_char_pascuero, l_string_kris;

// parentesis, cuento de navidad üéÑ
terminal p_abre_cuento, p_cierra_cuento;

// parentesis cuadrados, abrir empaque üéÅ
terminal p_abre_empaque, p_cierra_empaque;

// llaves, abrir regalo üéÅ
terminal cb_abre_regalo, cb_cierra_regalo;

// flujo de control, folklore navide√±o
terminal if_elfo, elif_hada, else_duende, for_envuelve;
terminal do_hace, until_revisa, return_envia, break_corta;

// print-read, habla y escucha üó£Ô∏èüëÇ
terminal print_habla, read_escucha;

// fin de expresion, fin regalo üéÅ
terminal fin_regalo;

// asignar, entregar üéÅ
terminal assign_entregar;

// separador, separador de regalos üéÅ
terminal sep_regalo;

// main, navidad üéÑ
terminal main_navidad;

// error, carb√≥n üéÅ
terminal error_carbon;

// palabras clave de tarea 1
// funci√≥n, chimenea üéÖ
terminal function_chimenea;
// definici√≥n de variable, dulce üç¨
terminal local_dulce;

/* Definici√≥n de gram√°tica - TAREA 1 */
non terminal navidad;
// no terminales para literales y para tipos
non terminal t_santa, l_santa, args_santa;

// no terminales para definiciones de funciones
non terminal funciones_bolsa_navidena, funcion_ayudante_santa, def_funcion_trineo, bloque_codigo_casa_jengibre; 
non terminal parametros_funcion_renos, parametro_funcion_reno;
// no terminales para definiciones de lineas de c√≥digo
non terminal linea_hombre_jengibre, lineas_hombre_jengibre;
// no terminales para asignacion de variables y expresiones
non terminal asignacion_adorno, expresion_regalo, elemento_arreglo_juguete, l_arr_gordo, asignacion_existente_nieve;
non terminal expr_ar_regaloprin, expr_rel_regalocomprado, expr_log_regalomanual;
// no terminales para flujo de control
non terminal retorno_carta_santa, llamada_func_pino, do_until_fabrica_juguetes;
non terminal for_vispera, if_travieso, elif_ayudante_lista, elif_lista_santa, else_inocente, if_declaracion_lista;

// Precedencia y asociatividad de operadores
precedence left op_res_rodolfo, op_sum_cupido;
precedence left op_div_bailarin, op_mul_cometa;
precedence left op_mod_rayo, op_pow_travieso;
precedence left op_inc_quien, op_dec_grinch;
precedence left op_eq_astuto, op_l_nevado, op_g_alegre, op_geq_feliz;
precedence left op_leq_copito, op_neq_chispa;
precedence left op_and_melchor;
precedence left op_or_gaspar;
precedence left op_not_baltasar;



start with navidad;

navidad ::= funciones_bolsa_navidena 
  {:
    exportarTablaSimbolos();
    imprimirTablaSimbolos();


    if (encontrarFuncion("main") == null) {
      System.out.println("Error sem√°ntico: no se encontro la funcion main");
    }

    for (FirmaFuncion firma : firmasFunciones) {
      if (!firma.isRetornaValor()) {
        System.out.println("Error sem√°ntico: la funcion " + firma.getNombre() + " no tiene return valido");
      }
    } 
  
    // escribir en el archivo de salida los 3 buffers
    try {
      File outputFile = new File(outputPath);
      FileWriter writer = new FileWriter(outputFile);
      writer.write(dataBuffer.toString());
      writer.write(codeBuffer.toString());
      writer.write(libBuffer.toString());
      writer.close();
      System.out.println("Archivo de salida generado en " + outputPath);
    } catch (IOException e) {
      System.out.println("Error al escribir en el archivo de salida");
      e.printStackTrace();
    }


  :};


t_santa ::= 
  t_int_colacho:t 
  {: RESULT = t; :}
  | t_float_santa:t
  {: RESULT = t; :}
  | t_bool_noel:t 
  {: RESULT = t; :}
  | t_char_pascuero:t
  {: RESULT = t; :}
  | t_string_kris:t 
  {: RESULT = t; :}
;
l_santa ::= 
  l_int_colacho:l
  {:
    // conseguir registro disponible
    var reg = getUnoccupiedRegister();
    // mover el valor del literal al registro
    codeBuffer.append("li " + reg + ", " + l + "\n");
    RESULT = new Expresion(l, TipoExpresion.INT, reg); 
  :}
  | l_float_santa:l
  {: 
    // a√±adir definici√≥n de float al dataBuffer
    var str = l.toString();
    var strId = "float" + literalId;

    dataBuffer.append(strId + ": .float " + str + "\n");
    ++literalId;
    // conseguir registro disponible
    var reg = getUnoccupiedRegister();
    codeBuffer.append("lw " + reg + ", " + strId + "\n");
    RESULT = new Expresion(l, TipoExpresion.FLOAT, reg);
    
  :}
  | l_t_noel:l
  {: 
    // cargar 1 en un registro
    var reg = getUnoccupiedRegister();
    codeBuffer.append("li " + reg + ", 1\n");
    RESULT = new Expresion(true, TipoExpresion.BOOL, reg);
  :}
  | l_f_noel:l
  {:
    // cargar 0 en un registro
    var reg = getUnoccupiedRegister();
    codeBuffer.append("li " + reg + ", 0\n");
    RESULT = new Expresion(false, TipoExpresion.BOOL, reg);
  :}
  | l_char_pascuero:l
  {: 
    // conseguir registro disponible
    var reg = getUnoccupiedRegister();
    // mover el valor del literal al registro
    codeBuffer.append("li " + reg + ", " + l + "\n");
    RESULT = new Expresion(l, TipoExpresion.CHAR, reg);
  
  :}
  | l_string_kris:l
  {:

    // a√±adir definici√≥n de string al dataBuffer
    var str = (String)l;
    var strId = "str" + literalId;

    dataBuffer.append(strId + ": .asciiz \"" + str + "\"\n");

    ++literalId;
    // conseguir registro disponible
    var reg = getUnoccupiedRegister();
    // mover la direcci√≥n del string al registro
    codeBuffer.append("la " + reg + ", " + strId + "\n");
    RESULT = new Expresion(l, TipoExpresion.STRING, reg);
  :}
  ;
args_santa ::= expresion_regalo:e
  {: 
    var arrL = new ArrayList<Expresion>();
    arrL.add((Expresion)e);
    RESULT = arrL;
  :}
  | args_santa:args sep_regalo expresion_regalo:e
  {: 
    var arrL = (ArrayList<Expresion>)args;
    arrL.add((Expresion)e);
    RESULT = arrL;
  :}
  ;
  

funciones_bolsa_navidena ::= funcion_ayudante_santa | funciones_bolsa_navidena funcion_ayudante_santa;
funcion_ayudante_santa ::=
  def_funcion_trineo:d bloque_codigo_casa_jengibre 
  {:
    var nombre_funcion = (String)d;
    // en el caso que la funci√≥n actual es la main, despu√©s de procesarla ocupo poner
    // el syscall de salida del programa
    if (nombre_funcion != null && nombre_funcion.equals("main")) {
      codeBuffer.append("li $v0, 10\n"); // syscall para terminar el programa
      codeBuffer.append("syscall\n");
    }
  :}
  | 
  error def_funcion_trineo:d bloque_codigo_casa_jengibre
  {:

    var nombre_funcion = (String)d;
    // en el caso que la funci√≥n actual es la main, despu√©s de procesarla ocupo poner
    // el syscall de salida del programa
    if (nombre_funcion != null && nombre_funcion.equals("main")) {
      codeBuffer.append("li $v0, 10\n"); // syscall para terminar el programa
      codeBuffer.append("syscall\n");
    }
  :};
// atrapa el error de statements fuera de funciones

def_funcion_trineo ::= 
  function_chimenea:f t_int_colacho main_navidad p_abre_cuento p_cierra_cuento 
  // funci√≥n main sin par√°metros que retorna un int
  {:

    // 1. validaci√≥n de que main no existe
    if (encontrarFuncion("main") != null) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion main ya declarada");
    } else {
      setHash("main");
      RESULT = "main";
      addSymbol(new SymbolTableObject("funcion", "int", "main"));
      addFirmaFuncion(new FirmaFuncion("main", TipoExpresion.INT, true, new TipoExpresion[] {}));
      // funci√≥n main no tiene por qu√© tener return, por lo tanto lo asignamos true por defecto
      // 2. inserci√≥n de label
      codeBuffer.append("main:\n");
    }

  :}
  |
  function_chimenea:f t_santa:tipo id_persona:id p_abre_cuento p_cierra_cuento 
  {:
    // 1. Validaci√≥n de que el retorno sea v√°lido
    // (char, int, float, bool)
    var str_tipo = tipo.toString();
    if (str_tipo != "char" && str_tipo != "int" && str_tipo != "float" && str_tipo != "bool") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + str_tipo + " no valido para una funcion");
    }
    else {
      // 2. Validaci√≥n de que la funci√≥n no existe
      if (encontrarFuncion(id.toString()) != null) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
      } else {
        setHash(id.toString());
        RESULT = id.toString();
        addSymbol(new SymbolTableObject("funcion", tipo.toString(), id.toString()));
        addFirmaFuncion(new FirmaFuncion(id.toString(), Expresion.tipoFromString(tipo.toString()), false, new TipoExpresion[] {}));
        // 3. inserci√≥n de label
        codeBuffer.append("_" + id.toString() + ":\n");
      }
    }
  :}
  | // sin parametros
  function_chimenea:f t_santa:tipo id_persona:id p_abre_cuento
  {: 
    // 1. Validaci√≥n de que el retorno sea v√°lido
    // (char, int, float, bool)
    var str_tipo = tipo.toString();
    if (str_tipo != "char" && str_tipo != "int" && str_tipo != "float" && str_tipo != "bool") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + str_tipo + " no valido para una funcion");
    }
    else {
      // 2. Validaci√≥n de que la funci√≥n no existe
      if (encontrarFuncion(id.toString()) != null) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
      } else {
        setHash(id.toString());
        RESULT = id.toString();
        addSymbol(new SymbolTableObject("funcion", tipo.toString(), id.toString()));
        addFirmaFuncion(new FirmaFuncion(id.toString(), Expresion.tipoFromString(tipo.toString()), false, new TipoExpresion[] {}));
        // 3. inserci√≥n de label
        codeBuffer.append("_" + id.toString() + ":\n");
      }
    }
  :}

  parametros_funcion_renos p_cierra_cuento
  ; // con parametros

parametros_funcion_renos ::= parametro_funcion_reno | parametros_funcion_renos sep_regalo parametro_funcion_reno;
parametro_funcion_reno ::= 
  t_santa:t id_persona:id
  {:
    addSymbol(new SymbolTableObject("parametro", t.toString(), id.toString()));
    // Conseguir la funci√≥n actual y meterle el par√°metro
    functionActual().addTipoParametro(Expresion.tipoFromString(t.toString()));
  :}
  ;
elemento_arreglo_juguete ::= 
  id_persona:id p_abre_empaque expresion_regalo:e p_cierra_empaque
  {:
    var e_expr = (Expresion)e;
    var tipo = e_expr.getTipo();
    var tipo_id = getTipo(id.toString(), true);
    RESULT = new Expresion("null", TipoExpresion.NULL);
    if (tipo != TipoExpresion.INT) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para indexar arreglo");
    } // validar que sea un arreglo 
    else if (tipo_id != TipoExpresion.INT_ARR && tipo_id != TipoExpresion.CHAR_ARR){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo_id.toString() + " no es un arreglo");
    } else {
      // 1. conseguir el registro donde est√° el valor de la expresi√≥n
      var reg = ((Expresion)e).getDireccion();
      // 2. multiplicar el valor por 4 (bit shift left 2)
      codeBuffer.append("sll " + reg + ", " + reg + ", 2\n");
      // 3. conseguir un nuevo registro, cargar la direcci√≥n del arreglo y sumarle el valor del registro
      var reg2 = getUnoccupiedRegister();
      codeBuffer.append("la " + reg2 + ", " + getDireccion(id.toString()) + "\n");
      codeBuffer.append("add " + reg2 + ", " + reg2 + ", " + reg + "\n");
      // 4. cargar el valor en la direcci√≥n del registro
      codeBuffer.append("lw " + reg + ", 0(" + reg2 + ")\n");
      // 5. retornar el valor 
      RESULT = new Expresion(reg2, Expresion.fromArr(tipo_id), reg);

    }
  :}  
;

bloque_codigo_casa_jengibre ::= cb_abre_regalo lineas_hombre_jengibre cb_cierra_regalo | cb_abre_regalo error cb_cierra_regalo; // atrapa errores dentro de bloques

retorno_carta_santa ::=
  return_envia expresion_regalo:e 
  {:
    var tipo = ((Expresion)e).getTipo();
    var tipoFuncion = functionActual().getTipoRetorno();
    if (tipo != tipoFuncion) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + tipo.toString() + " no valido para una funcion de tipo " + tipoFuncion.toString());
    }
    else {
      functionActual().setRetornaValor(true);
      // mover el valor de la expresi√≥n al registro de retorno ($v0)
      codeBuffer.append("move $v0, " + ((Expresion)e).getDireccion() + "\n");
      codeBuffer.append("jr $ra\n");
    }
  :}|
  return_envia {:
    // 1. validar que el break est√© dentro de una estructura de control
    // (if, for, do-until)
    var top = tablasSimbolos.get(currentHash).controlStackNonIfTop();
    if (top == null){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Return fuera de estructura de control");
    }
    else {
      // 2. agregar el salto al final de la estructura de control
      codeBuffer.append("j " + top + "_fin\n");
    }
  :}; // sin expresion de retorno, este solamente se usa como un "break"

linea_hombre_jengibre ::= 
  asignacion_adorno fin_regalo|
  retorno_carta_santa fin_regalo|
  expresion_regalo fin_regalo|
  break_corta fin_regalo {:
    // 1. validar que el break est√© dentro de una estructura de control
    // (if, for, do-until)
    var top = tablasSimbolos.get(currentHash).controlStackNonIfTop();
    if (top == null){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Break fuera de estructura de control");
    }
    else {
      // 2. agregar el salto al final de la estructura de control
      codeBuffer.append("j " + top + "_fin\n");
    }
  :}|
  do_until_fabrica_juguetes fin_regalo|
  for_vispera|
  bloque_codigo_casa_jengibre| // permite bloques sueltos 
  if_travieso|
  error fin_regalo; // recuperaci√≥n de errores

llamada_func_pino ::= 
  id_persona p_abre_cuento p_cierra_cuento | // a()
  id_persona p_abre_cuento args_santa p_cierra_cuento | 
  print_habla p_abre_cuento args_santa:args p_cierra_cuento {:
    var expr_args = (ArrayList<Expresion>)args;

    for (Expresion e : expr_args) {
      // hacer un switch con los diferentes tipos de la expresi√≥n
      // y generar el c√≥digo de acuerdo al tipo
      switch (e.getTipo()) {
        case STRING:
          // cargar el contenido de la direccion de la expresi√≥n en $a0
          codeBuffer.append("move $a0, " + e.getDireccion() + "\n");
          codeBuffer.append("li $v0, 4\n");
          codeBuffer.append("syscall\n");

          break;

        case INT:
          // cargar el contenido de la expresi√≥n en $a0
          // recordar que e.getDireccion() es el registro donde est√° el valor
          codeBuffer.append("move $a0, " + e.getDireccion() + "\n");
          codeBuffer.append("li $v0, 1\n");
          codeBuffer.append("syscall\n");
          break;

        case FLOAT:
          // cargar el contenido de la expresi√≥n en $f12
          // recordar que e.getDireccion() es el registro donde est√° el valor
          // .getDireccion() siempre maneja registros de uso general

          // 1. pasar de uso general a $f12
          codeBuffer.append("mtc1 " + e.getDireccion() + ", $f12\n");
          codeBuffer.append("li $v0, 2\n");
          codeBuffer.append("syscall\n");
          break;
        // default error sem√°ntico
        default:
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e.getTipo().toString() + " no valido para print");
          break;
      }
    }
    // despu√©s de imprimir todos los argumentos, imprimir un enter
    codeBuffer.append("la $a0, endl\n");
    codeBuffer.append("li $v0, 4\n");
    codeBuffer.append("syscall\n");
    RESULT = new Expresion("null", TipoExpresion.NULL);
  :}| // print(a, b, ...)

  
  print_habla p_abre_cuento p_cierra_cuento {:
    // generaci√≥n de c√≥digo de print endl 
    codeBuffer.append("la $a0, endl\n");
    codeBuffer.append("li $v0, 4\n");
    codeBuffer.append("syscall\n");
    RESULT = new Expresion("null", TipoExpresion.NULL);
  :}| // print() -> Imprimir un salto de linea
  read_escucha p_abre_cuento id_persona:id p_cierra_cuento {:
    // validar que string exista y tenga tipo v√°lido
    var tipo = getTipo(id.toString(), true);
    var dir = getDireccion(id.toString());
    switch (tipo){
      case INT:
        // leer un int
        codeBuffer.append("li $v0, 5\n");
        codeBuffer.append("syscall\n");
        // guardar el valor en el registro de la variable
        codeBuffer.append("sw $v0, " + dir + "\n");
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
      case FLOAT:
        // leer un float
        codeBuffer.append("li $v0, 6\n");
        codeBuffer.append("syscall\n");
        // guardar el valor en el registro de la variable
        codeBuffer.append("swc1 $f0, " + dir + "\n");
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
      default:
        break;
    }
  
    RESULT = new Expresion("null", TipoExpresion.NULL);
  :}| // read(a)
  read_escucha p_abre_cuento elemento_arreglo_juguete:eaj p_cierra_cuento{:
    // verificar que el elemento del arreglo sea un int (tiene tipo int)
    var tipo = ((Expresion)eaj).getTipo();
    if (tipo == TipoExpresion.INT) {
      // leer un int
      codeBuffer.append("li $v0, 5\n");
      codeBuffer.append("syscall\n");
      // guardar el valor en el registro de la variable
      String dir = (String)((Expresion)eaj).getValor(); // string con la direcci√≥n del √≠ndice del arreglo
      codeBuffer.append("sw $v0, 0(" + dir + ")\n");
    }
    else {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para read");
    }

    RESULT = new Expresion("null", TipoExpresion.NULL);
  :}; // read(a[1])


lineas_hombre_jengibre ::= 
  linea_hombre_jengibre 
  {: 
    // limpiar los registros sin usar
    refrescarRegistros();
    refrescarRegistrosFloat();
    // a√±adir un enter al codigo (para depruar)
    codeBuffer.append("\n");
  :}
  |
  lineas_hombre_jengibre linea_hombre_jengibre
  {:
    // limpiar los registros sin usar
    refrescarRegistros();
    refrescarRegistrosFloat();
    // a√±adir un enter al codigo (para depruar)
    codeBuffer.append("\n");
  :}
  ;

l_arr_gordo ::= cb_abre_regalo args_santa:a cb_cierra_regalo
{:
  var arrL = (ArrayList<Expresion>)a;
  var valido = true;

  // iterar sobre el arreglo y verificar que todos los elementos sean del mismo tipo
  // y que el tipo sea char o int

  TipoExpresion tipo = arrL.get(0).getTipo();
  if (tipo != TipoExpresion.INT && tipo != TipoExpresion.CHAR) {
    System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para arreglo");
    RESULT = new Expresion("null", TipoExpresion.NULL);
    valido = false;
  }
  for (Expresion e : arrL) {
    if (e.getTipo() != tipo) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e.getTipo().toString() + " no valido para un literal de arreglo de tipo " + tipo.toString());
      RESULT = new Expresion("null", TipoExpresion.NULL);
      valido = false;  
      break;
    }
  }

  if (valido){
    // finalmente, retornar una nueva expresi√≥n con el tipo de dato del arreglo
    if (tipo == TipoExpresion.INT) {
      RESULT = new Expresion(arrL, TipoExpresion.INT_ARR);
    }
    else {
      RESULT = new Expresion(arrL, TipoExpresion.CHAR_ARR);
    }
  }


:};

do_until_fabrica_juguetes ::=
  do_hace {:
    // conseguir nuevo label
    var label = "do" + labelId;
    // agregar el label al stack de control
    tablasSimbolos.get(currentHash).controlStackPush(label);
    // agregar el label al codeBuffer
    codeBuffer.append(label + ":\n");
    ++labelId;
  :} bloque_codigo_casa_jengibre until_revisa p_abre_cuento expresion_regalo:e p_cierra_cuento
  
  {:
    // 1. validar que la expresi√≥n sea booleana, sino, error sem√°ntico
    var expr = (Expresion)e;
    if (expr.getTipo() != TipoExpresion.BOOL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una expresion booleana");
    }
    else {
      // 2. si la expresi√≥n es falsa, saltar al label del do
      var label = tablasSimbolos.get(currentHash).controlStackTop();
      codeBuffer.append("beq " + expr.getDireccion() + ", $zero, " + label + "\n");
      // 4. agregar el label del fin del do
      codeBuffer.append(label + "_fin:\n");
      // 5. sacar el label del stack de control
      tablasSimbolos.get(currentHash).controlStackPop();
    }
  :}
  ; // do {} until (a)|

for_vispera ::=
  for_envuelve p_abre_cuento asignacion_existente_nieve {:
    // despu√©s del c√≥digo de la asignaci√≥n, se entra al for
    // conseguir nuevo label
    var label = "for" + labelId;
    // agregar el label al stack de control
    tablasSimbolos.get(currentHash).controlStackPush(label);
    // agregar el label al codeBuffer
    codeBuffer.append(label + ":\n");
    ++labelId;
  :}
  fin_regalo expresion_regalo:e {:
    // error sem√°ntico si la expresi√≥n no es booleana
    var expr = (Expresion)e;
    var label = tablasSimbolos.get(currentHash).controlStackTop();
    if (expr.getTipo() != TipoExpresion.BOOL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una expresion booleana");
      codeBuffer.append("j " + label + "_fin\n");
    }
    else {
      // si la expresi√≥n es falsa, saltar al fin del for
      codeBuffer.append("beq " + expr.getDireccion() + ", $zero, " + label + "_fin\n");
    }
  :}
  
  fin_regalo {:
    var label = tablasSimbolos.get(currentHash).controlStackTop();
    // no queremos llegar aqui desde arriba, asi que saltamos al final
    codeBuffer.append("j inc" + label + "_fin\n");
    codeBuffer.append("inc" + label + ":\n");
  :}
  
  expresion_regalo:inc {:
    var label = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append("j " + label + "\n");
    codeBuffer.append("inc" + label + "_fin:\n");
  :}
  
  p_cierra_cuento bloque_codigo_casa_jengibre
  {:
    codeBuffer.append("j inc" + tablasSimbolos.get(currentHash).controlStackTop() + "\n");
    var label = tablasSimbolos.get(currentHash).controlStackTop();
    // generar el fin
    codeBuffer.append(label + "_fin:\n");
    // sacar el label del stack de control
    tablasSimbolos.get(currentHash).controlStackPop();
  :}; // for (a| b| c) {}


if_declaracion_lista ::= if_elfo {:
  // iniciar estructura IF 
  tablasSimbolos.get(currentHash).controlStackPush("if" + labelId);
  codeBuffer.append("if" + labelId + ":\n");
  ++labelId;

:} p_abre_cuento expresion_regalo:e p_cierra_cuento {:
  // revisar tipado de la expresi√≥n
  var expr = (Expresion)e;
  var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
  if (expr.getTipo() != TipoExpresion.BOOL) {
    System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una expresion booleana");
    // saltar directamente al fin
    codeBuffer.append("j " + branchActual + "_fin\n");
  }
  else {
    // si no es cierta la expresi√≥n, saltar al fin
    codeBuffer.append("beq " + expr.getDireccion() + ", $zero, " + branchActual + "_false\n");
  }

:} bloque_codigo_casa_jengibre:b {:
  // se salta al fin para evitar caer encima de un else/elif
  var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
  codeBuffer.append("j " + branchActual + "_fin\n");

  // si nada del bloque se cumplio, recurrir al _false
  codeBuffer.append(branchActual + "_false:\n");
  // esto para igual aceptar un else y un elif.

:};

if_travieso ::=
  if_declaracion_lista {:
    // terminar estructura IF 
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append(branchActual + "_fin:\n");
    tablasSimbolos.get(currentHash).controlStackPop();
  :}| // if (a) {}
  if_declaracion_lista elif_ayudante_lista  {:
    // terminar estructura IF
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append(branchActual + "_fin:\n");
    tablasSimbolos.get(currentHash).controlStackPop();
  :}| // if (a) {} elif (b) {} elif ...
  if_declaracion_lista else_inocente {:
    // esta branch funciona autom√°ticamente, ya que en falso, saltamos a ifX_false 
    // y entre ifX_false y ifX_fin est√° el c√≥digo del else (previamente procesado)
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append(branchActual + "_fin:\n");
    tablasSimbolos.get(currentHash).controlStackPop();
  
  :}| // if (a) {} else {}
  if_declaracion_lista elif_ayudante_lista else_inocente {:
    // igualmente, esta branch funciona autom√°ticamente, ya que si ningun elif se cumple
    // nunca se salta a ifX_end sino a ifX_elifY_fin, y entre ifX_elifY_fin e ifX_fin
    // est√° el c√≥digo del else (previamente procesado)
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append(branchActual + "_fin:\n");
    tablasSimbolos.get(currentHash).controlStackPop();
  
  :}; // if (a) {} elif (b) {} elif ... else {}

elif_ayudante_lista ::=
  elif_lista_santa | elif_ayudante_lista elif_lista_santa;

elif_lista_santa ::=
  elif_hada p_abre_cuento expresion_regalo:e p_cierra_cuento {:
    // conseguir un nuevo label
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    var branchNuevo = branchActual + "_elif" + labelId;
    // dar error si el tipo de la expresi√≥n no es booleano
    var expr = (Expresion)e;
    if (expr.getTipo() != TipoExpresion.BOOL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una expresion booleana");
      codeBuffer.append("j " + branchNuevo + "_fin\n");
    }
    else {
      // si no es cierta la expresi√≥n, saltar al fin del elif (no del if, ya que puede haber m√°s elifs)
      codeBuffer.append("beq " + expr.getDireccion() + ", $zero, " + branchNuevo + "_fin\n");
    }
  :}
  
  bloque_codigo_casa_jengibre{:
    // despu√©s del c√≥digo, al cerrar esta rama se salta al fin del if
    var branchActual = tablasSimbolos.get(currentHash).controlStackTop();
    codeBuffer.append("j " + branchActual + "_fin\n");
    // se crea el label del fin del elif
    var branchNuevo = branchActual + "_elif" + labelId;
    codeBuffer.append(branchNuevo + "_fin:\n");
    ++labelId; 
  :};

else_inocente ::=
  else_duende bloque_codigo_casa_jengibre;

asignacion_adorno ::= 
  local_dulce t_santa:t id_persona:id 
  {:

    if (getTipo(id.toString(), false) != TipoExpresion.NULL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
    }
    else {
      addSymbol(new SymbolTableObject("local", t.toString(), id.toString()));
      addDireccion(id.toString(), String.valueOf(tablasSimbolos.get(currentHash).getCurrentSize()) + "($sp)");
      tablasSimbolos.get(currentHash).increaseSize(4);
      // si es una string, agregar el valor de endl por defecto.
      if (t.toString() == "string") {
        var reg = getUnoccupiedRegister();
        codeBuffer.append("la " + reg + ", endl\n");
        codeBuffer.append("sw " + reg + ", " + getDireccion(id.toString()) + "\n");
      }
      // si es un int, agregar 0 por defecto.
      if (t.toString() == "int") {
        var reg = getUnoccupiedRegister();
        codeBuffer.append("li " + reg + ", 0\n");
        codeBuffer.append("sw " + reg + ", " + getDireccion(id.toString()) + "\n");
      }
      // si es un float, agregar 0.0 por defecto.
      if (t.toString() == "float") {
        var reg = getUnoccupiedRegister();
        codeBuffer.append("lw " + reg + ", fzero\n");
        codeBuffer.append("sw " + reg + ", " + getDireccion(id.toString()) + "\n");
      }
      // si es un bool, agregar 0 por defecto.
      if (t.toString() == "bool") {
        var reg = getUnoccupiedRegister();
        codeBuffer.append("li " + reg + ", 0\n");
        codeBuffer.append("sw " + reg + ", " + getDireccion(id.toString()) + "\n");
      }
      // si es un char, agregar ' ' por defecto.
      if (t.toString() == "char") {
        var reg = getUnoccupiedRegister();
        codeBuffer.append("li " + reg + ", 32\n");
        codeBuffer.append("sw " + reg + ", " + getDireccion(id.toString()) + "\n");
      }
    }

  :} 
  | // local int a|
  local_dulce:l t_santa:t id_persona:el p_abre_empaque l_int_colacho:l_int p_cierra_empaque
  {:
    if(t.toString() != "int" && t.toString() != "char"){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + t.toString() + " no valido para arreglo");
    }
    else {

      var i_arr = (int)l_int;
      if (i_arr <= 0) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + i_arr + " no valida");
      }
      else {
        if (getTipo(el.toString(), false) != TipoExpresion.NULL) {
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + el.toString() + " ya declarada");
        }
        else {
          addSymbol(new SymbolTableObject("local", t.toString() + "[]", el.toString()));
          addDireccion(el.toString(), String.valueOf(tablasSimbolos.get(currentHash).getCurrentSize()) + "($sp)");
          tablasSimbolos.get(currentHash).increaseSize(4 * i_arr);
          // si es un char[], agregar el valor de ' ' por defecto.
          if (t.toString() == "char") {
            var reg = getUnoccupiedRegister();
            var reg2 = getUnoccupiedRegister();
            codeBuffer.append("li " + reg + ", 32\n");
            // cargar en el otro registro la direcci√≥n de la variable
            codeBuffer.append("la " + reg2 + ", " + getDireccion(el.toString()) + "\n");
            for (int i = 0; i < i_arr; ++i) {
              codeBuffer.append("sw " + reg + ", " + i * 4 + "(" + reg2 + ")\n");
            }
          }
          // si es un int[], agregar el valor de 0 por defecto.
          if (t.toString() == "int") {
            var reg = getUnoccupiedRegister();
            var reg2 = getUnoccupiedRegister();
            codeBuffer.append("li " + reg + ", 0\n");
            // cargar en el otro registro la direcci√≥n de la variable
            codeBuffer.append("la " + reg2 + ", " + getDireccion(el.toString()) + "\n");
            for (int i = 0; i < i_arr; ++i) {
              codeBuffer.append("sw " + reg + ", " + i * 4 + "(" + reg2 + ")\n");
            }
          }
        }
      }
    }
  :}
  | // local int a[1]|
  local_dulce t_santa:t id_persona:id assign_entregar expresion_regalo:e
  {:
    if (getTipo(id.toString(), false) != TipoExpresion.NULL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
    } else {

      var expr = (Expresion)e;
      if (expr.getTipo() != Expresion.tipoFromString(t.toString())) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una variable de tipo " + t.toString());
      }
      else {
        addSymbol(new SymbolTableObject("local", t.toString(), id.toString()));
        addDireccion(id.toString(), String.valueOf(tablasSimbolos.get(currentHash).getCurrentSize()) + "($sp)");
        tablasSimbolos.get(currentHash).increaseSize(4);
        // si es una string, mover la direcci√≥n del string a la variable
        if (t.toString() == "string") {

          // conseguir la direcci√≥n del id 
          var dir = getDireccion(id.toString());
          // mover el valor de la expresi√≥n a la direcci√≥n del id
          var reg = getUnoccupiedRegister();
          codeBuffer.append("move " + reg + ", " + expr.getDireccion() + "\n");
          codeBuffer.append("sw " + reg + ", " + dir + "\n");
        } else {
          // mover e.getDireccion() (registro en el que est√° almacenado el literal)
          // hacia la direcci√≥n del id
          var dir = getDireccion(id.toString());
          codeBuffer.append("sw " + expr.getDireccion() + ", " + dir + "\n");
        }
      }
    }

  :}
  | // local int a <= 1|
  local_dulce:l t_santa:t id_persona:el p_abre_empaque l_int_colacho:l_int p_cierra_empaque assign_entregar l_arr_gordo:l_arr
  {:
    if (t.toString() != "int" && t.toString() != "char") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + t.toString() + " no valido para arreglo");
    }
    else {
      // Si llegamos aqu√≠, sabemos que el tipo que buscamos es int o char
      // Y que recibimos un literal de arreglo que puede estar mal formado (NULL)
      // O bien formado con un tipo de dato que no es el que buscamos
      var e_arr = (Expresion)l_arr;
      if (e_arr.getTipo() == TipoExpresion.NULL){
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Literal de arreglo mal formado");
      }
      else {

        TipoExpresion tipo = Expresion.tipoFromString(t.toString() + "[]");

        if (e_arr.getTipo() != tipo){
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e_arr.getTipo().toString() + " no valido para una variable de tipo " + tipo.toString());
        }
        else {
          // finalmente, asegurar que la longitud es la misma entre el arreglo y el literal
          var arr = (ArrayList<Expresion>)e_arr.getValor();
          if ((int)l_int != arr.size()) {
            System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + l_int + " no coincide con la longitud del literal de arreglo " + arr.size());
          }
          else {

            if (getTipo(el.toString(), false) != TipoExpresion.NULL) {
              System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + el.toString() + " ya declarada");
            }
            else {
              addSymbol(new SymbolTableObject("local", t.toString() + "[]", el.toString()));
              addDireccion(el.toString(), String.valueOf(tablasSimbolos.get(currentHash).getCurrentSize()) + "($sp)");
              tablasSimbolos.get(currentHash).increaseSize(4 * arr.size());
              // cargamos el registro en el que qued√≥ cada expresi√≥n en el arreglo
              var reg2 = getUnoccupiedRegister();
              // cargar direcci√≥n de la variable en reg2
              codeBuffer.append("la " + reg2 + ", " + getDireccion(el.toString()) + "\n");
              for (int i = 0; i < arr.size(); ++i) {
                codeBuffer.append("sw " + arr.get(i).getDireccion() + ", " + i * 4 + "(" + reg2 + ")\n");
              }
            }
          }
        }
      }
    }
  :}
  | // local int a[1] <= {1}
  asignacion_existente_nieve; // si ya existe la variable, no se agrega a la tabla de simbolos

asignacion_existente_nieve ::=
  id_persona:id assign_entregar expresion_regalo:e {:
    var expr = (Expresion)e;
    var tipoId = getTipo(id.toString(), true);
    if (tipoId != expr.getTipo()) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una variable de tipo " + tipoId.toString());
    }
    else {
      // conseguir la direcci√≥n del id 
      var dir = getDireccion(id.toString());
      // mover el valor de la expresi√≥n a la direcci√≥n del id
      var reg = getUnoccupiedRegister();

      codeBuffer.append("move " + reg + ", " + expr.getDireccion() + "\n");
      codeBuffer.append("sw " + reg + ", " + dir + "\n");
  
      
    }
  
  :}| // a <= 1|
  elemento_arreglo_juguete:eaj assign_entregar expresion_regalo:e {:
    var expr_eaj = (Expresion)eaj;
    var expr_e = (Expresion)e;

    if (expr_eaj.getTipo() != expr_e.getTipo()){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr_e.getTipo().toString() + " no valido para una variable de tipo " + expr_eaj.getTipo().toString());
    } else if (expr_eaj.getTipo() == TipoExpresion.NULL){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Asignaci√≥n mal formada.");
    }
    else {
      // conseguir la direcci√≥n del id 
      var dir = (String)expr_eaj.getValor();
      var reg = expr_e.getDireccion();
      // mover el valor de la expresi√≥n a la direcci√≥n del id
      codeBuffer.append("sw " + reg + ", 0(" + dir + ")\n");
    }
  :}; // a[1] <= 1|

expresion_regalo ::=
  l_santa:l
  {:
    RESULT = l;
  :}
  | 
  id_persona:id
  {:
    // validar que existe la variable
    if (getTipo(id.toString(), true) != TipoExpresion.NULL) {
      // cargar el valor de la variable en un registro
      var dir = getDireccion(id.toString());
      var registro = getUnoccupiedRegister();
      codeBuffer.append("lw " + registro + ", " + dir + "\n");
      RESULT = new Expresion(id.toString(), getTipo(id.toString(), true), registro);
    } else {
      RESULT = new Expresion("null", TipoExpresion.NULL);
    }
  :}
  | 
  elemento_arreglo_juguete:eaj
  {:
    RESULT = eaj;
  :}
  | p_abre_cuento expresion_regalo:e p_cierra_cuento
  {: RESULT = e; :}
  | expr_ar_regaloprin:e
  {: RESULT = e; :}
  | expr_rel_regalocomprado:e
  {: RESULT = e; :}
  | expr_log_regalomanual:e
  {: RESULT = e; :}
  | llamada_func_pino:e
  {: RESULT = e; :};

expr_ar_regaloprin ::= 
  expresion_regalo:a op_res_rodolfo expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var reg = getUnoccupiedRegister();
    var b_expr = (Expresion)b;
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("-", a_expr, b_expr, arraylist_tipos_validos);

    switch (tipo_res) {
      case INT: 
        // limpiar reg
        codeBuffer.append("li " + reg + ", 0\n");
        // restar a_expr y b_expr
        codeBuffer.append("sub " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " - " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;
      case FLOAT:
        var fRegA = getUnoccupiedFloatRegister();
        var fRegB = getUnoccupiedFloatRegister();
        codeBuffer.append("mtc1 " + a_expr.getDireccion() + ", " + fRegA + "\n");
        codeBuffer.append("mtc1 " + b_expr.getDireccion() + ", " + fRegB + "\n");
        codeBuffer.append("sub.s " + fRegA + ", " + fRegA + ", " + fRegB + "\n");
        codeBuffer.append("mfc1 " + reg + ", " + fRegA + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " - " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }


  :}| // a - b
  expresion_regalo:a op_sum_cupido expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("+", a_expr, b_expr, arraylist_tipos_validos);
    var reg = getUnoccupiedRegister();
    // switch para el tipo resultante, para finalmente pasar la direccion resultado
    // a un nuevo registro y retornar una nueva expresi√≥n
    switch (tipo_res) {
      case INT:
        // limpiar reg
        codeBuffer.append("li " + reg + ", 0\n");
        // sumar a_expr y b_expr
        codeBuffer.append("add " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " + " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;

      case FLOAT:
        // para las operaciones flotantes, como las direcciones siempre
        // est√°n en registros de uso general, hay que pasarlas a registros
        // flotantes antes de hacer cualquier cosa.
        var fRegA = getUnoccupiedFloatRegister();
        var fRegB = getUnoccupiedFloatRegister();
        // pasar a fReg el valor de a_expr
        codeBuffer.append("mtc1 " + a_expr.getDireccion() + ", " + fRegA + "\n");
        // pasar a fReg el valor de b_expr
        codeBuffer.append("mtc1 " + b_expr.getDireccion() + ", " + fRegB + "\n");
        // sumar a_expr y b_expr
        codeBuffer.append("add.s " + fRegA + ", " + fRegA + ", " + fRegB + "\n");
        // pasar el resultado a un nuevo registro de uso general
        codeBuffer.append("mfc1 " + reg + ", " + fRegA + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " + " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);        
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }

  :}| // a + b
  expresion_regalo:a op_div_bailarin expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var reg = getUnoccupiedRegister();
    var b_expr = (Expresion)b;
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("/", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case INT:
        // limpiar reg
        codeBuffer.append("li " + reg + ", 0\n");
        // dividir a_expr y b_expr
        codeBuffer.append("div " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        // guardar el resultado en reg
        codeBuffer.append("mflo " + reg + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " / " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;
      case FLOAT:
        var fRegA = getUnoccupiedFloatRegister();
        var fRegB = getUnoccupiedFloatRegister();
        codeBuffer.append("mtc1 " + a_expr.getDireccion() + ", " + fRegA + "\n");
        codeBuffer.append("mtc1 " + b_expr.getDireccion() + ", " + fRegB + "\n");
        codeBuffer.append("div.s " + fRegA + ", " + fRegA + ", " + fRegB + "\n");
        codeBuffer.append("mfc1 " + reg + ", " + fRegA + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " / " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  
  :}| // a / b
  expresion_regalo:a op_mul_cometa expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("*", a_expr, b_expr, arraylist_tipos_validos);

    switch (tipo_res) {
      case INT:
        // limpiar reg
        codeBuffer.append("li " + reg + ", 0\n");
        // multiplicar a_expr y b_expr
        codeBuffer.append("mul " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " * " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;
      case FLOAT: 
        var fRegA = getUnoccupiedFloatRegister();
        var fRegB = getUnoccupiedFloatRegister();
        codeBuffer.append("mtc1 " + a_expr.getDireccion() + ", " + fRegA + "\n");
        codeBuffer.append("mtc1 " + b_expr.getDireccion() + ", " + fRegB + "\n");
        codeBuffer.append("mul.s " + fRegA + ", " + fRegA + ", " + fRegB + "\n");
        codeBuffer.append("mfc1 " + reg + ", " + fRegA + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " * " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  :}| // a * b
  expresion_regalo:a op_mod_rayo expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;

    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("~", a_expr, b_expr, arraylist_tipos_validos);
  
    var reg = getUnoccupiedRegister();
    switch(tipo_res) {
      case INT:
        // limpiar reg
        codeBuffer.append("li " + reg + ", 0\n");
        // dividir a_expr y b_expr
        codeBuffer.append("div " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        // guardar el resultado en reg
        codeBuffer.append("mfhi " + reg + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " ~ " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;
      case FLOAT:
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // 2. guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // 3. llamar a la funci√≥n
        codeBuffer.append("jal moduloFloat\n");
        // 4. meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // 5. recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " ~ " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}| // a ~ b
  expresion_regalo:a op_pow_travieso expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("**", a_expr, b_expr, arraylist_tipos_validos);

    switch (tipo_res) {
      case INT:
        // 1. meter los datos a $a0 y $a1
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // 2. guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // 3. llamar a la funci√≥n
        codeBuffer.append("jal expInt\n");
        // 4. meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // 5. recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " ** " + b_expr.getValor().toString(), TipoExpresion.INT, reg);
        break;
      case FLOAT:
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // 2. guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // 3. llamar a la funci√≥n
        codeBuffer.append("jal pow\n");
        // 4. meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // 5. recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " ** " + b_expr.getValor().toString(), TipoExpresion.FLOAT, reg);

        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}| // a ** b
  op_inc_quien id_persona:id {:
    // conseguir la direcci√≥n de la variable
    var dir = getDireccion(id.toString());
    var reg = getUnoccupiedRegister();
    if (dir == null){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " no declarada");
      RESULT = new Expresion("null", TipoExpresion.NULL);
    }
    else {
      // conseguir el tipo de la variable (si tiene direcci√≥n tambi√©n tiene tipo)
      var tipo = getTipo(id.toString(), false);
      switch (tipo) {
        case INT:
          // conseguir valor en la direcci√≥n carg√°ndolo a un registro
          codeBuffer.append("lw " + reg + ", " + dir + "\n");
          // sumar 1 al registro
          codeBuffer.append("addi " + reg + ", " + reg + ", 1\n");
          // guardar el valor en la direcci√≥n
          codeBuffer.append("sw " + reg + ", " + dir + "\n");
          RESULT = new Expresion(id.toString() + "++", TipoExpresion.INT, reg);

          break;
        case FLOAT:
          // conseguir valor en la direcci√≥n carg√°ndolo a un registro flotante
          var fReg = getUnoccupiedFloatRegister();
          codeBuffer.append("l.s " + fReg + ", " + dir + "\n");
          // cargar 1 en un registro flotante
          var fRegOne = getUnoccupiedFloatRegister();
          codeBuffer.append("l.s " + fRegOne + ", fone\n");
          // sumar 1 al registro
          codeBuffer.append("add.s " + fReg + ", " + fReg + ", " + fRegOne + "\n");
          // guardar el valor en la direcci√≥n
          codeBuffer.append("s.s " + fReg + ", " + dir + "\n");
          // cargar el valor del registro flotante a un registro de uso general
          codeBuffer.append("mfc1 " + reg + ", " + fReg + "\n");
          RESULT = new Expresion(id.toString() + "++", TipoExpresion.FLOAT, reg);

          break;
        default:
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para incremento");
          RESULT = new Expresion("null", TipoExpresion.NULL);
      }
    }


  :}| // ++a
  op_dec_grinch id_persona:id {:
    // Conseguir direcci√≥n de la variable
    var dir = getDireccion(id.toString());
    var reg = getUnoccupiedRegister();
    if (dir == null){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " no declarada");
      RESULT = new Expresion("null", TipoExpresion.NULL);
    } else {
      var tipo = getTipo(id.toString(), false);
      switch (tipo) {
        case INT:
          // conseguir valor en la direcci√≥n carg√°ndolo a un registro
          codeBuffer.append("lw " + reg + ", " + dir + "\n");
          // restar 1 al registro
          codeBuffer.append("addi " + reg + ", " + reg + ", -1\n");
          // guardar el valor en la direcci√≥n
          codeBuffer.append("sw " + reg + ", " + dir + "\n");
          RESULT = new Expresion(id.toString() + "--", TipoExpresion.INT, reg);

          break;
        case FLOAT:
          // conseguir valor en la direcci√≥n carg√°ndolo a un registro flotante
          var fReg = getUnoccupiedFloatRegister();
          codeBuffer.append("l.s " + fReg + ", " + dir + "\n");
          // cargar 1 en un registro flotante
          var fRegOne = getUnoccupiedFloatRegister();
          codeBuffer.append("l.s " + fRegOne + ", fone\n");
          // restar 1 al registro
          codeBuffer.append("sub.s " + fReg + ", " + fReg + ", " + fRegOne + "\n");
          // guardar el valor en la direcci√≥n
          codeBuffer.append("s.s " + fReg + ", " + dir + "\n");
          // cargar el valor del registro flotante a un registro de uso general
          codeBuffer.append("mfc1 " + reg + ", " + fReg + "\n");
          RESULT = new Expresion(id.toString() + "--", TipoExpresion.FLOAT, reg);

          break;
        default:
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para decremento");
          RESULT = new Expresion("null", TipoExpresion.NULL);
      }
    }
  :}| // --a
  op_dec_grinch elemento_arreglo_juguete:eaj {:
    // validar tipado INT
    var eaj_expr = (Expresion)eaj;
    var reg = getUnoccupiedRegister();
    var tipo_res = validarTipado("--", eaj_expr, new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT)));
    if (tipo_res == TipoExpresion.INT) {
      // conseguir la direcci√≥n del id 
      var dir = (String)eaj_expr.getValor();
      // conseguir valor en la direcci√≥n carg√°ndolo a un registro
      codeBuffer.append("lw " + reg + ", " + "0(" + dir + ")\n");
      // restar 1 al registro
      codeBuffer.append("addi " + reg + ", " + reg + ", -1\n");
      // guardar el valor en la direcci√≥n
      codeBuffer.append("sw " + reg + ", 0(" + dir + ")\n");
      RESULT = new Expresion(eaj_expr.getValor().toString() + "--", TipoExpresion.INT, reg);
    }
    else {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + eaj_expr.getTipo().toString() + " no valido para decremento");
      RESULT = new Expresion("null", TipoExpresion.NULL);
    }
  :}
  | // --a[1]
  op_inc_quien elemento_arreglo_juguete:eaj {:
    // validar tipado INT
    var eaj_expr = (Expresion)eaj;
    var reg = getUnoccupiedRegister();
    var tipo_res = validarTipado("++", eaj_expr, new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT)));
    if (tipo_res == TipoExpresion.INT) {
      // conseguir la direcci√≥n del id 
      var dir = (String)eaj_expr.getValor();
      // conseguir valor en la direcci√≥n carg√°ndolo a un registro
      codeBuffer.append("lw " + reg + ", 0(" + dir + ")\n");
      // sumar 1 al registro
      codeBuffer.append("addi " + reg + ", " + reg + ", 1\n");
      // guardar el valor en la direcci√≥n
      codeBuffer.append("sw " + reg + ", 0(" + dir + ")\n");
      RESULT = new Expresion(eaj_expr.getValor().toString() + "++", TipoExpresion.INT, reg);
    }
    else {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + eaj_expr.getTipo().toString() + " no valido para incremento");
      RESULT = new Expresion("null", TipoExpresion.NULL);
    }  
  :}; // ++a[1]

expr_rel_regalocomprado ::=
  expresion_regalo:a op_eq_astuto expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT, TipoExpresion.BOOL));
    var tipo_res = validarTipado("==", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case INT:
      case BOOL: // ambos tienen el mismo procedimiento
        codeBuffer.append("sub " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        codeBuffer.append("sltiu " + reg + ", " + reg + ", 1\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " == " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
      break;

      case FLOAT:
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal eqFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " == " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);

      break; 
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  
  :}| // a == b
  expresion_regalo:a op_l_nevado expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("<", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res){
      case INT:
        codeBuffer.append("slt " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " < " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
      break;
      case FLOAT: 
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal ltFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " < " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}| // a < b
  expresion_regalo:a op_g_alegre expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado(">", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res){
      case INT:
        codeBuffer.append("slt " + reg + ", " + b_expr.getDireccion() + ", " + a_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " > " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
      break;
      case FLOAT:
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a1, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a0, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal ltFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " > " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  :}| // a > b
  expresion_regalo:a op_geq_feliz expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("=>", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res){ 
      case INT: 
        codeBuffer.append("slt " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n"); // convierte 0 a 1 y 1 a 0 (xor con 1)
        RESULT = new Expresion(a_expr.getValor().toString() + " >= " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;

      case FLOAT: 
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal ltFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // xor con 1
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n");
        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " >= " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  :}| // a => b
  expresion_regalo:a op_leq_copito expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT));
    var tipo_res = validarTipado("=<", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res){
      case INT:
        codeBuffer.append("slt " + reg + ", " + b_expr.getDireccion() + ", " + a_expr.getDireccion() + "\n");
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n"); // convierte 0 a 1 y 1 a 0 (xor con 1)
        // !(b < a) = b >= a
        RESULT = new Expresion(a_expr.getValor().toString() + " <= " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      case FLOAT:
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a1, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a0, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal ltFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // xor con 1
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n");

        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        // !(b < a) = b >= a
        RESULT = new Expresion(a_expr.getValor().toString() + " <= " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}| // a =< b
  expresion_regalo:a op_neq_chispa expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.INT, TipoExpresion.FLOAT, TipoExpresion.BOOL));
    var tipo_res = validarTipado("!=", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case INT:
      case BOOL:
        codeBuffer.append("sub " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        codeBuffer.append("sltiu " + reg + ", " + reg + ", 1\n");
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n"); // convierte 0 a 1 y 1 a 0 (xor con 1) 
        RESULT = new Expresion(a_expr.getValor().toString() + " != " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      case FLOAT:
        // guardar mi $ra en la pila para no sobreescribirlo
        // al llamar la funci√≥n
        codeBuffer.append("addi $sp, $sp, -4\n");
        codeBuffer.append("sw $ra, 0($sp)\n");
        // cargar los valores de a_expr y b_expr en $a0 y $a1
        codeBuffer.append("move $a0, " + a_expr.getDireccion() + "\n");
        codeBuffer.append("move $a1, " + b_expr.getDireccion() + "\n");
        // llamar a la funci√≥n
        codeBuffer.append("jal eqFloat\n");
        // meter el resultado en reg
        codeBuffer.append("move " + reg + ", $v0\n");
        // xor con 1
        codeBuffer.append("xori " + reg + ", " + reg + ", 1\n");
        // recuperar $ra de la pila
        codeBuffer.append("lw $ra, 0($sp)\n");
        codeBuffer.append("addi $sp, $sp, 4\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " != " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}; // a != b

expr_log_regalomanual ::=
  expresion_regalo:a op_and_melchor expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.BOOL));
    var tipo_res = validarTipado("^", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case BOOL:
        codeBuffer.append("and " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " ^ " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  
  :}| // a ^ b
  expresion_regalo:a op_or_gaspar expresion_regalo:b {:
    var a_expr = (Expresion)a;
    var b_expr = (Expresion)b;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.BOOL));
    var tipo_res = validarTipado("#", a_expr, b_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case BOOL:
        codeBuffer.append("or " + reg + ", " + a_expr.getDireccion() + ", " + b_expr.getDireccion() + "\n");
        RESULT = new Expresion(a_expr.getValor().toString() + " # " + b_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }
  :}| // a # b
  op_not_baltasar expresion_regalo:a {:
    var a_expr = (Expresion)a;
    var reg = getUnoccupiedRegister();
    var arraylist_tipos_validos = new ArrayList<TipoExpresion>(Arrays.asList(TipoExpresion.BOOL));
    var tipo_res = validarTipado("!", a_expr, arraylist_tipos_validos);
    switch (tipo_res) {
      case BOOL:
        codeBuffer.append("xori " + reg + ", " + a_expr.getDireccion() + ", 1\n");
        RESULT = new Expresion("!" + a_expr.getValor().toString(), TipoExpresion.BOOL, reg);
        break;
      default:
        RESULT = new Expresion("null", TipoExpresion.NULL);
        break;
    }  
  :}; // !a

/*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*/