import java_cup.runtime.*;
import java.util.*;
import java.io.*;

action code {:
  /** 
  * funciones p√∫blicas de pruebas para el lexer, por ahora
  * solo imprimen en consola
  * entrada: ninguna
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola
  */
  HashMap<String, ArrayList<SymbolTableObject>> tablasSimbolos = new HashMap<String, ArrayList<SymbolTableObject>>();
  String currentHash = "";
  ArrayList<FirmaFuncion> firmasFunciones = new ArrayList<FirmaFuncion>();
  ArrayList<String> registrosSinUsar = new ArrayList<String>(Arrays.asList("$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9"));

  public void refrescarRegistros() {
    registrosSinUsar = new ArrayList<String>(Arrays.asList("$t1", "$t2", "$t3", "$t4", "$t5", "$t6", "$t7", "$t8", "$t9"));
  }

  int currSize = 0; // cual es el tama√±o de la tabla de simbolos actual

  public void addFirmaFuncion(FirmaFuncion firma) {
    firmasFunciones.add(firma);
  }

  public String getUnoccupiedRegister() {
    
    if (registrosSinUsar.size() == 0) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "No hay registros disponibles");
      return "$t0";
    }
    var reg = registrosSinUsar.get(0);
    registrosSinUsar.remove(0);
    return reg;
  }

  public FirmaFuncion encontrarFuncion(String id) {
    for (FirmaFuncion firma : firmasFunciones) {
      if (firma.getNombre().equals(id)) {
        return firma;
      }
    }
    return null;
  }

  public FirmaFuncion functionActual() {
    return firmasFunciones.get(firmasFunciones.size() - 1);
  }


  /**
  * funci√≥n para imprimir la tabla de s√≠mbolos
  * entrada: ninguna
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola la tabla de s√≠mbolos
  */
  public void imprimirTablaSimbolos() {
    for (String key : tablasSimbolos.keySet()) {
      System.out.println("Tabla de simbolo : " + key);
      System.out.println("Valores : ");
      for (SymbolTableObject value : tablasSimbolos.get(key)) {
        System.out.println(value.toString());
      }
      System.out.println();
    }
  }

  public void exportarTablaSimbolos() {
    List<String[]> data = new ArrayList<String[]>();
    data.add(new String[] {"Tabla", "TipoEntrada", "Nombre", "TipoDato"});
    for (String key : tablasSimbolos.keySet()) {
      for (SymbolTableObject value : tablasSimbolos.get(key)) {
        data.add(new String[] {key, value.getTipoEntrada(), value.getNombre(), value.getTipoDato()});
      }
    }
    MarkdownTablePrinter tablePrinter = new MarkdownTablePrinter(data, "src/main/test/tabla_sim.md");
    tablePrinter.print();
    System.out.println("Tabla de simbolos exportada a tabla_sim.md");
  }

  /**
  * Funci√≥n para conseguir el tipo de un s√≠mbolo en la tabla de s√≠mbolos actual
  * entrada: un string
  * salida: un Expresion.TipoExpresion
  * restricciones: ninguna
  * objetivo: conseguir el tipo de un s√≠mbolo en la tabla de s√≠mbolos actual
  */
  public TipoExpresion getTipo(String nombre, boolean picarError) {
    for (SymbolTableObject value : tablasSimbolos.get(currentHash)) {
      if (value.getNombre().equals(nombre)) {
        return Expresion.tipoFromString(value.getTipoDato());
      }
    }
    if (picarError){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + nombre + " no declarada en el alcance actual");
    }
    return TipoExpresion.NULL;
  }

  public void addDireccion(String id, String dir){
    for (SymbolTableObject value : tablasSimbolos.get(currentHash)) {
      if (value.getNombre().equals(id)) {
        value.setDireccion(dir);
      }
    }
  }

  public String getDireccion(String id){
    for (SymbolTableObject value : tablasSimbolos.get(currentHash)) {
      if (value.getNombre().equals(id)) {
        return value.getDireccion();
      }
    }
    return null;
  }


  /**
  * funci√≥n para cambiar el hash actual al que se le asocian los s√≠mbolos
  * entrada: un string
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: cambiar el hash actual
  */
  public void setHash(String hash) {
    currentHash = hash;
    tablasSimbolos.put(hash, new ArrayList<SymbolTableObject>());
  }
  /**
  * funci√≥n para agregar un s√≠mbolo a la tabla de s√≠mbolos
  * entrada: un objeto de la clase SymbolTableObject
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: agregar un s√≠mbolo a la tabla de s√≠mbolos
  */
  public void addSymbol(SymbolTableObject symbol) {
    tablasSimbolos.get(currentHash).add(symbol);
  }
:}

parser code {:
  Lexer lex;
  int literalId = 0;
  String outputPath;
  private final String LIB_PATH = "src/main/asm/santalib.asm";

  StringBuffer dataBuffer = new StringBuffer();
  StringBuffer codeBuffer = new StringBuffer();
  StringBuffer libBuffer = new StringBuffer();

  /* cargar libreria */

  public void cargarLibreria() {
    try {
      File libFile = new File(LIB_PATH);
      java.util.Scanner libScanner = new java.util.Scanner(libFile);
      while (libScanner.hasNextLine()) {
        String line = libScanner.nextLine();
        libBuffer.append(line + "\n");
      }
      libScanner.close();
    } catch (FileNotFoundException e) {
      System.out.println("Error al cargar la libreria");
      e.printStackTrace();
    }
  }

  public void inicializarBuffers(){
    // carga los buffer codeBuffer y dataBuffer con .text y .data
    codeBuffer.append(".text\n");
    dataBuffer.append(".data\n");
    // a√±adir un endl al dataBuffer 
    dataBuffer.append("endl: .asciiz \"\\n\"\n");
  }


  /**
  * Constructor de la clase parser
  * entrada: un lexer
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: inicializar el lexer y el symbolFactory
  */
  public parser(Lexer lex, String outputPath) {
    this.lex = lex;
    this.outputPath = outputPath;
    cargarLibreria();
    inicializarBuffers();
    this.symbolFactory = new DefaultSymbolFactory();
  }
  /**
  * Sobreescritura de m√©todos para el manejo de errores
  * entrada: un entero y un s√≠mbolo
  * salida: ninguna
  * restricciones: ninguna
  * objetivo: imprimir en consola el error
  */
  public void syntax_error(Symbol token) {
    if (token.value == null){
      return;
    }
    System.out.println("Error de sintaxis en la linea " + token.left + " columna " + token.right + ": " + token.value);
    System.out.println("Continuando...");
  }
  public void unrecovered_syntax_error(Symbol token) throws java.lang.Exception {
    if (token.value == null){
      throw new Exception("Error de sintaxis irrecuperable al final del archivo");
    }
    throw new Exception("Error de sintaxis irrecuperable en la linea " + token.left + " columna " + token.right + ": " + token.value);
  }



:}

// como se escanean e inicializan los tokens
scan with {: return lex.next_token(); :};
init with {: :};

// Definici√≥n de terminales (tokens) a usar
// operaciones aritm√©ticas binarias, renos de Santa ü¶åü¶åü¶åü¶åü¶åü¶åü¶å
terminal op_res_rodolfo, op_sum_cupido, op_div_bailarin;
terminal op_mul_cometa, op_mod_rayo, op_pow_travieso;

// operaciones aritm√©ticas unarias, grinch-quien üéÑüòàüéÖüíö
terminal op_inc_quien, op_dec_grinch;

// operadores relacionales, elfos üßù
terminal op_eq_astuto, op_l_nevado, op_g_alegre, op_geq_feliz;
terminal op_leq_copito, op_neq_chispa; 

// expresiones logicas, reyes magos üëëüëëüëë
terminal op_and_melchor, op_or_gaspar, op_not_baltasar;

// identificador, persona üßë
terminal id_persona;

// tipos de datos, nombres de pap√° noel üéÖüéÖüéÖüéÖüéÖüéÖ
terminal t_int_colacho, t_float_santa, t_bool_noel, t_char_pascuero;
terminal t_string_kris, t_null_reno;

// literales, nombres de pap√° noel üéÖüéÖüéÖüéÖüéÖüéÖ
terminal l_int_colacho, l_float_santa, l_t_noel, l_f_noel;
terminal l_char_pascuero, l_string_kris;

// parentesis, cuento de navidad üéÑ
terminal p_abre_cuento, p_cierra_cuento;

// parentesis cuadrados, abrir empaque üéÅ
terminal p_abre_empaque, p_cierra_empaque;

// llaves, abrir regalo üéÅ
terminal cb_abre_regalo, cb_cierra_regalo;

// flujo de control, folklore navide√±o
terminal if_elfo, elif_hada, else_duende, for_envuelve;
terminal do_hace, until_revisa, return_envia, break_corta;

// print-read, habla y escucha üó£Ô∏èüëÇ
terminal print_habla, read_escucha;

// fin de expresion, fin regalo üéÅ
terminal fin_regalo;

// asignar, entregar üéÅ
terminal assign_entregar;

// separador, separador de regalos üéÅ
terminal sep_regalo;

// main, navidad üéÑ
terminal main_navidad;

// error, carb√≥n üéÅ
terminal error_carbon;

// palabras clave de tarea 1
// funci√≥n, chimenea üéÖ
terminal function_chimenea;
// definici√≥n de variable, dulce üç¨
terminal local_dulce;

/* Definici√≥n de gram√°tica - TAREA 1 */
non terminal navidad;
// no terminales para literales y para tipos
non terminal t_santa, l_santa, args_santa;

// no terminales para definiciones de funciones
non terminal funciones_bolsa_navidena, funcion_ayudante_santa, def_funcion_trineo, bloque_codigo_casa_jengibre; 
non terminal parametros_funcion_renos, parametro_funcion_reno;
// no terminales para definiciones de lineas de c√≥digo
non terminal linea_hombre_jengibre, lineas_hombre_jengibre;
// no terminales para asignacion de variables y expresiones
non terminal asignacion_adorno, expresion_regalo, elemento_arreglo_juguete, l_arr_gordo, asignacion_existente_nieve;
non terminal expr_ar_regaloprin, expr_rel_regalocomprado, expr_log_regalomanual;
// no terminales para flujo de control
non terminal retorno_carta_santa, llamada_func_pino, do_until_fabrica_juguetes;
non terminal for_vispera, if_travieso, elif_ayudante_lista, elif_lista_santa, else_inocente;

// Precedencia y asociatividad de operadores
precedence left op_res_rodolfo, op_sum_cupido;
precedence left op_div_bailarin, op_mul_cometa;
precedence left op_mod_rayo, op_pow_travieso;
precedence left op_inc_quien, op_dec_grinch;
precedence left op_eq_astuto, op_l_nevado, op_g_alegre, op_geq_feliz;
precedence left op_leq_copito, op_neq_chispa;
precedence left op_and_melchor;
precedence left op_or_gaspar;
precedence left op_not_baltasar;



start with navidad;

navidad ::= funciones_bolsa_navidena 
  {:
    exportarTablaSimbolos();
    imprimirTablaSimbolos();


    if (encontrarFuncion("main") == null) {
      System.out.println("Error sem√°ntico: no se encontro la funcion main");
    }

    for (FirmaFuncion firma : firmasFunciones) {
      if (!firma.isRetornaValor()) {
        System.out.println("Error sem√°ntico: la funcion " + firma.getNombre() + " no tiene return valido");
      }
    } 
  
    // escribir en el archivo de salida los 3 buffers
    try {
      File outputFile = new File(outputPath);
      FileWriter writer = new FileWriter(outputFile);
      writer.write(dataBuffer.toString());
      writer.write(codeBuffer.toString());
      writer.write(libBuffer.toString());
      writer.close();
      System.out.println("Archivo de salida generado en " + outputPath);
    } catch (IOException e) {
      System.out.println("Error al escribir en el archivo de salida");
      e.printStackTrace();
    }


  :};


t_santa ::= 
  t_int_colacho:t 
  {: RESULT = t; :}
  | t_float_santa:t
  {: RESULT = t; :}
  | t_bool_noel:t 
  {: RESULT = t; :}
  | t_char_pascuero:t
  {: RESULT = t; :}
  | t_string_kris:t 
  {: RESULT = t; :}
;
l_santa ::= 
  l_int_colacho:l
  {: RESULT = new Expresion(l, TipoExpresion.INT); :}
  | l_float_santa:l
  {: RESULT = new Expresion(l, TipoExpresion.FLOAT); :}
  | l_t_noel:l
  {: RESULT = new Expresion(true, TipoExpresion.BOOL); :}
  | l_f_noel:l
  {: RESULT = new Expresion(false, TipoExpresion.BOOL); :}
  | l_char_pascuero:l
  {: RESULT = new Expresion(l, TipoExpresion.CHAR); :}
  | l_string_kris:l
  {:

    // a√±adir definici√≥n de string al dataBuffer
    var str = (String)l;
    var strId = "str" + literalId;

    dataBuffer.append(strId + ": .asciiz \"" + str + "\"\n");

    ++literalId;
    // conseguir registro disponible
    var reg = getUnoccupiedRegister();
    // mover la direcci√≥n del string al registro
    codeBuffer.append("la " + reg + ", " + strId + "\n");
    RESULT = new Expresion(l, TipoExpresion.STRING, reg);
  :}
  ;
args_santa ::= expresion_regalo:e
  {: 
    var arrL = new ArrayList<Expresion>();
    arrL.add((Expresion)e);
    RESULT = arrL;
  :}
  | args_santa:args sep_regalo expresion_regalo:e
  {: 
    var arrL = (ArrayList<Expresion>)args;
    arrL.add((Expresion)e);
    RESULT = arrL;
  :}
  ;
  

funciones_bolsa_navidena ::= funcion_ayudante_santa | funciones_bolsa_navidena funcion_ayudante_santa;
funcion_ayudante_santa ::=
  def_funcion_trineo:d bloque_codigo_casa_jengibre 
  {:
    var nombre_funcion = (String)d;
    // en el caso que la funci√≥n actual es la main, despu√©s de procesarla ocupo poner
    // el syscall de salida del programa
    if (nombre_funcion != null && nombre_funcion.equals("main")) {
      codeBuffer.append("li $v0, 10\n"); // syscall para terminar el programa
      codeBuffer.append("syscall\n");
    }
  :}
  | 
  error def_funcion_trineo:d bloque_codigo_casa_jengibre
  {:

    var nombre_funcion = (String)d;
    // en el caso que la funci√≥n actual es la main, despu√©s de procesarla ocupo poner
    // el syscall de salida del programa
    if (nombre_funcion != null && nombre_funcion.equals("main")) {
      codeBuffer.append("li $v0, 10\n"); // syscall para terminar el programa
      codeBuffer.append("syscall\n");
    }
  :};
// atrapa el error de statements fuera de funciones

def_funcion_trineo ::= 
  function_chimenea:f t_int_colacho main_navidad p_abre_cuento p_cierra_cuento 
  // funci√≥n main sin par√°metros que retorna un int
  {:

    // 1. validaci√≥n de que main no existe
    if (encontrarFuncion("main") != null) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion main ya declarada");
    } else {
      setHash("main");
      RESULT = "main";
      addSymbol(new SymbolTableObject("funcion", "int", "main"));
      addFirmaFuncion(new FirmaFuncion("main", TipoExpresion.INT, true, new TipoExpresion[] {}));
      // funci√≥n main no tiene por qu√© tener return, por lo tanto lo asignamos true por defecto
      // 2. inserci√≥n de label
      codeBuffer.append("main:\n");
    }

  :}
  |
  function_chimenea:f t_santa:tipo id_persona:id p_abre_cuento p_cierra_cuento 
  {:
    // 1. Validaci√≥n de que el retorno sea v√°lido
    // (char, int, float, bool)
    var str_tipo = tipo.toString();
    if (str_tipo != "char" && str_tipo != "int" && str_tipo != "float" && str_tipo != "bool") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + str_tipo + " no valido para una funcion");
    }
    else {
      // 2. Validaci√≥n de que la funci√≥n no existe
      if (encontrarFuncion(id.toString()) != null) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
      } else {
        setHash(id.toString());
        RESULT = id.toString();
        addSymbol(new SymbolTableObject("funcion", tipo.toString(), id.toString()));
        addFirmaFuncion(new FirmaFuncion(id.toString(), Expresion.tipoFromString(tipo.toString()), false, new TipoExpresion[] {}));
        // 3. inserci√≥n de label
        codeBuffer.append("_" + id.toString() + ":\n");
      }
    }
  :}
  | // sin parametros
  function_chimenea:f t_santa:tipo id_persona:id p_abre_cuento
  {: 
    // 1. Validaci√≥n de que el retorno sea v√°lido
    // (char, int, float, bool)
    var str_tipo = tipo.toString();
    if (str_tipo != "char" && str_tipo != "int" && str_tipo != "float" && str_tipo != "bool") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + str_tipo + " no valido para una funcion");
    }
    else {
      // 2. Validaci√≥n de que la funci√≥n no existe
      if (encontrarFuncion(id.toString()) != null) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Funcion " + id.toString() + " ya declarada");
      } else {
        setHash(id.toString());
        RESULT = id.toString();
        addSymbol(new SymbolTableObject("funcion", tipo.toString(), id.toString()));
        addFirmaFuncion(new FirmaFuncion(id.toString(), Expresion.tipoFromString(tipo.toString()), false, new TipoExpresion[] {}));
        // 3. inserci√≥n de label
        codeBuffer.append("_" + id.toString() + ":\n");
      }
    }
  :}

  parametros_funcion_renos p_cierra_cuento
  ; // con parametros

parametros_funcion_renos ::= parametro_funcion_reno | parametros_funcion_renos sep_regalo parametro_funcion_reno;
parametro_funcion_reno ::= 
  t_santa:t id_persona:id
  {:
    addSymbol(new SymbolTableObject("parametro", t.toString(), id.toString()));
    // Conseguir la funci√≥n actual y meterle el par√°metro
    functionActual().addTipoParametro(Expresion.tipoFromString(t.toString()));
  :}
  ;
elemento_arreglo_juguete ::= 
  id_persona:id p_abre_empaque expresion_regalo p_cierra_empaque
  {:
    RESULT = id.toString();
  :}  
;

bloque_codigo_casa_jengibre ::= cb_abre_regalo lineas_hombre_jengibre cb_cierra_regalo | cb_abre_regalo error cb_cierra_regalo; // atrapa errores dentro de bloques

retorno_carta_santa ::=
  return_envia expresion_regalo:e 
  {:
    var tipo = ((Expresion)e).getTipo();
    var tipoFuncion = functionActual().getTipoRetorno();
    if (tipo != tipoFuncion) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de retorno " + tipo.toString() + " no valido para una funcion de tipo " + tipoFuncion.toString());
    }
    else {
      functionActual().setRetornaValor(true);
    }
  
  
  :}
  
  |
  return_envia; // sin expresion de retorno

linea_hombre_jengibre ::= 
  asignacion_adorno fin_regalo|
  retorno_carta_santa fin_regalo|
  expresion_regalo fin_regalo|
  break_corta fin_regalo|
  do_until_fabrica_juguetes fin_regalo|
  for_vispera|
  bloque_codigo_casa_jengibre| // permite bloques sueltos 
  if_travieso|
  error fin_regalo; // recuperaci√≥n de errores

llamada_func_pino ::= 
  id_persona p_abre_cuento p_cierra_cuento | // a()
  id_persona p_abre_cuento args_santa p_cierra_cuento | 
  print_habla p_abre_cuento args_santa:args p_cierra_cuento {:
    var expr_args = (ArrayList<Expresion>)args;

    for (Expresion e : expr_args) {
      // hacer un switch con los diferentes tipos de la expresi√≥n
      // y generar el c√≥digo de acuerdo al tipo
      switch (e.getTipo()) {
        case STRING:
          var expr = (Expresion)e;
          // cargar el contenido de la direccion de la expresi√≥n en $a0
          codeBuffer.append("move $a0, " + expr.getDireccion() + "\n");
          
          
          codeBuffer.append("jal printString\n"); 
          break;
        // default error sem√°ntico
        default:
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e.getTipo().toString() + " no valido para print");
          break;
      }
    }
    // despu√©s de imprimir todos los argumentos, imprimir un enter
    codeBuffer.append("la $a0, endl\n");
    codeBuffer.append("jal printString\n");
  :}| // print(a, b, ...)
  
  print_habla p_abre_cuento p_cierra_cuento {:
    // generaci√≥n de c√≥digo de print endl 
    codeBuffer.append("la $a0, endl\n");
    codeBuffer.append("jal printString\n"); 
  :}| // print() -> Imprimir un salto de linea
  read_escucha p_abre_cuento id_persona p_cierra_cuento | // read(a)
  read_escucha p_abre_cuento elemento_arreglo_juguete p_cierra_cuento; // read(a[1])


lineas_hombre_jengibre ::= 
  linea_hombre_jengibre 
  {: 
    // limpiar los registros sin usar
    refrescarRegistros();
    // a√±adir un enter al codigo (para depruar)
    codeBuffer.append("\n");
  :}
  |
  lineas_hombre_jengibre linea_hombre_jengibre
  {:
    // limpiar los registros sin usar
    refrescarRegistros();
    // a√±adir un enter al codigo (para depruar)
    codeBuffer.append("\n");
  :}
  ;

l_arr_gordo ::= cb_abre_regalo args_santa:a cb_cierra_regalo
{:
  var arrL = (ArrayList<Expresion>)a;
  var valido = true;

  // iterar sobre el arreglo y verificar que todos los elementos sean del mismo tipo
  // y que el tipo sea char o int

  TipoExpresion tipo = arrL.get(0).getTipo();
  if (tipo != TipoExpresion.INT && tipo != TipoExpresion.CHAR) {
    System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + tipo.toString() + " no valido para arreglo");
    RESULT = new Expresion("null", TipoExpresion.NULL);
    valido = false;
  }
  for (Expresion e : arrL) {
    if (e.getTipo() != tipo) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e.getTipo().toString() + " no valido para un literal de arreglo de tipo " + tipo.toString());
      RESULT = new Expresion("null", TipoExpresion.NULL);
      valido = false;  
      break;
    }
  }

  if (valido){
    // finalmente, retornar una nueva expresi√≥n con el tipo de dato del arreglo
    if (tipo == TipoExpresion.INT) {
      RESULT = new Expresion(arrL, TipoExpresion.INT_ARR);
    }
    else {
      RESULT = new Expresion(arrL, TipoExpresion.CHAR_ARR);
    }
  }


:};

do_until_fabrica_juguetes ::=
  do_hace bloque_codigo_casa_jengibre until_revisa p_abre_cuento expresion_regalo p_cierra_cuento; // do {} until (a)|

for_vispera ::=
  for_envuelve p_abre_cuento asignacion_existente_nieve fin_regalo expresion_regalo fin_regalo expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre; // for (a| b| c) {}

if_travieso ::=
  if_elfo p_abre_cuento expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre| // if (a) {}
  if_elfo p_abre_cuento expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre elif_ayudante_lista| // if (a) {} elif (b) {} elif ...
  if_elfo p_abre_cuento expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre else_inocente| // if (a) {} else {}
  if_elfo p_abre_cuento expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre elif_ayudante_lista else_inocente; // if (a) {} elif (b) {} elif ... else {}

elif_ayudante_lista ::=
  elif_lista_santa | elif_ayudante_lista elif_lista_santa;

elif_lista_santa ::=
  elif_hada p_abre_cuento expresion_regalo p_cierra_cuento bloque_codigo_casa_jengibre;

else_inocente ::=
  else_duende bloque_codigo_casa_jengibre;

asignacion_adorno ::= 
  local_dulce t_santa:t id_persona:id 
  {:

    if (getTipo(id.toString(), false) != TipoExpresion.NULL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
    }
    else {
      addSymbol(new SymbolTableObject("local", t.toString(), id.toString()));

      // si es una string, agregar el valor de endl por defecto.
      if (t.toString() == "string") {
        addDireccion(id.toString(), String.valueOf(currSize) + "($sp)");
        currSize += 4;
        codeBuffer.append("la $t0, endl\n");
      }

    }

  :} 
  | // local int a|
  local_dulce:l t_santa:t id_persona:el p_abre_empaque l_int_colacho:l_int p_cierra_empaque
  {:
    if(t.toString() != "int" && t.toString() != "char"){
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + t.toString() + " no valido para arreglo");
    }
    else {

      var i_arr = (int)l_int;
      if (i_arr <= 0) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + i_arr + " no valida");
      }
      else {
        if (getTipo(el.toString(), false) != TipoExpresion.NULL) {
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + el.toString() + " ya declarada");
        }
        else {
          addSymbol(new SymbolTableObject("local", t.toString() + "[]", el.toString()));
        }
      }
    }
  :}
  | // local int a[1]|
  local_dulce t_santa:t id_persona:id assign_entregar expresion_regalo:e
  {:
    if (getTipo(id.toString(), false) != TipoExpresion.NULL) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + id.toString() + " ya declarada");
    } else {

      var expr = (Expresion)e;
      if (expr.getTipo() != Expresion.tipoFromString(t.toString())) {
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una variable de tipo " + t.toString());
      }
      else {
        addSymbol(new SymbolTableObject("local", t.toString(), id.toString()));
        // si es una string, mover la direcci√≥n del string a la variable
        if (t.toString() == "string") {
          addDireccion(id.toString(), String.valueOf(currSize) + "($sp)");
          currSize += 4;
          // conseguir la direcci√≥n del id 
          var dir = getDireccion(id.toString());
          // mover el valor de la expresi√≥n a la direcci√≥n del id
          codeBuffer.append("move $t0, " + expr.getDireccion() + "\n");
          codeBuffer.append("sw $t0, " + dir + "\n");
        }
      }
    }

  :}
  | // local int a <= 1|
  local_dulce:l t_santa:t id_persona:el p_abre_empaque l_int_colacho:l_int p_cierra_empaque assign_entregar l_arr_gordo:l_arr
  {:
    if (t.toString() != "int" && t.toString() != "char") {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + t.toString() + " no valido para arreglo");
    }
    else {
      // Si llegamos aqu√≠, sabemos que el tipo que buscamos es int o char
      // Y que recibimos un literal de arreglo que puede estar mal formado (NULL)
      // O bien formado con un tipo de dato que no es el que buscamos
      var e_arr = (Expresion)l_arr;
      if (e_arr.getTipo() == TipoExpresion.NULL){
        System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Literal de arreglo mal formado");
      }
      else {

        TipoExpresion tipo = Expresion.tipoFromString(t.toString() + "[]");

        if (e_arr.getTipo() != tipo){
          System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + e_arr.getTipo().toString() + " no valido para una variable de tipo " + tipo.toString());
        }
        else {
          // finalmente, asegurar que la longitud es la misma entre el arreglo y el literal
          var arr = (ArrayList<Expresion>)e_arr.getValor();
          if ((int)l_int != arr.size()) {
            System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Longitud de arreglo " + l_int + " no coincide con la longitud del literal de arreglo " + arr.size());
          }
          else {

            if (getTipo(el.toString(), false) != TipoExpresion.NULL) {
              System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Variable " + el.toString() + " ya declarada");
            }
            else {
              addSymbol(new SymbolTableObject("local", t.toString() + "[]", el.toString()));
            }
          }
        }
      }
    }
  :}
  | // local int a[1] <= {1}
  asignacion_existente_nieve; // si ya existe la variable, no se agrega a la tabla de simbolos

asignacion_existente_nieve ::=
  id_persona:id assign_entregar expresion_regalo:e {:
    var expr = (Expresion)e;
    var tipoId = getTipo(id.toString(), true);
    if (tipoId != expr.getTipo()) {
      System.out.println("Error sem√°ntico en la linea " + lex.getLine() + " columna " + lex.getColumn() + ": " + "Tipo de dato " + expr.getTipo().toString() + " no valido para una variable de tipo " + tipoId.toString());
    }
    else {
      // si es una string, agregar la direcci√≥n de la expresi√≥n 
      if (tipoId == TipoExpresion.STRING) {
        // conseguir la direcci√≥n del id 
        var dir = getDireccion(id.toString());
        // mover el valor de la expresi√≥n a la direcci√≥n del id
        codeBuffer.append("move $t0, " + expr.getDireccion() + "\n");
        codeBuffer.append("sw $t0, " + dir + "\n");
      }
    }
  
  :}| // a <= 1|
  elemento_arreglo_juguete assign_entregar expresion_regalo; // a[1] <= 1|

expresion_regalo ::=
  l_santa:l
  {:
    RESULT = l;
  :}
  | 
  id_persona:id
  {:
    // cargar el valor de la variable en un registro
    var dir = getDireccion(id.toString());
    var registro = getUnoccupiedRegister();
    codeBuffer.append("lw " + registro + ", " + dir + "\n");
    RESULT = new Expresion(id.toString(), getTipo(id.toString(), true), registro);
  :}
  | 
  elemento_arreglo_juguete:eaj
  {:
    RESULT = new Expresion(eaj.toString(), getTipo(eaj.toString(), true));
  :}
  | p_abre_cuento expresion_regalo:e p_cierra_cuento
  {: RESULT = e; :}
  | expr_ar_regaloprin:e
  {: RESULT = e; :}
  | expr_rel_regalocomprado:e
  {: RESULT = e; :}
  | expr_log_regalomanual:e
  {: RESULT = e; :}
  | llamada_func_pino:e
  {: RESULT = e; :};

expr_ar_regaloprin ::= 
  expresion_regalo op_res_rodolfo expresion_regalo | // a - b
  expresion_regalo op_sum_cupido expresion_regalo | // a + b
  expresion_regalo op_div_bailarin expresion_regalo | // a / b
  expresion_regalo op_mul_cometa expresion_regalo | // a * b
  expresion_regalo op_mod_rayo expresion_regalo | // a ~ b
  expresion_regalo op_pow_travieso expresion_regalo | // a ** b
  op_inc_quien id_persona | // ++a
  op_dec_grinch id_persona | // --a
  op_dec_grinch elemento_arreglo_juguete | // --a[1]
  op_inc_quien elemento_arreglo_juguete; // ++a[1]

expr_rel_regalocomprado ::=
  expresion_regalo op_eq_astuto expresion_regalo | // a == b
  expresion_regalo op_l_nevado expresion_regalo | // a < b
  expresion_regalo op_g_alegre expresion_regalo | // a > b
  expresion_regalo op_geq_feliz expresion_regalo | // a => b
  expresion_regalo op_leq_copito expresion_regalo | // a =< b
  expresion_regalo op_neq_chispa expresion_regalo; // a != b

expr_log_regalomanual ::=
  expresion_regalo op_and_melchor expresion_regalo | // a ^ b
  expresion_regalo op_or_gaspar expresion_regalo | // a # b
  op_not_baltasar expresion_regalo; // !a

/*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*~*/